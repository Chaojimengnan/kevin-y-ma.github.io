# 2019贝壳找房四道笔试题

## 1. 计算绝对值

题目描述：  

给出n个正整数，要求将找出相邻两个数字中差的绝对值最小的一对数字，如果有差的绝对值相同的，则输出最前面的一对数。

输入：  

输入包含两行，第一行为n,第二行是用空格分隔的n个正整数。  

输出：  

输出包含一行两个正整数，要求按照原来的顺序输出。  

样例输入：  

```c++
9
1 3 4 7 2 6 5 12 32
```

样例输出：  

```c++
3 4
```

code

```c++
#include <iostream>

using namespace std;
int main()
{
        int n = 0;
        cin>>n;
        int nums[n];
        for (int i=0; i<n; i++)
                cin>>nums[i];

        int min_dif = abs(nums[1]-nums[0]);
        int l = nums[0];
        int r = nums[1];

        for (int i=1; i<n; i++) {
                int dif = abs(nums[i+1] - nums[i]);
                if(dif < min_dif) {
                        l = nums[i];
                        r = nums[i+1];
                        min_dif = dif;
                }
        }
        cout<<l<<" "<<r<<endl;

        return 0;
}
```

## 2. 举重大赛

题目描述：  

举重大赛开始了，为了保证公平，要求比赛的双方体重较小值要大于等于较大值的90%，那么对于这N个人最多能进行多少场比赛呢？任意两人之间醉倒进行一场比赛。  

输入：  

第一行：一个整数N，表示参赛人数（2<=N<=10^5）

第二行： N个正整数表示体重（0<体重<=10^8）

输出： 

一个数，表示最多能进行的比赛场数  

样例输入：  
```c++
5
1 1 1 1 1
```

样例输出：  

```c++
10
```

code

```c++
#include <iostream>

using namespace std;
int main()
{
        int n = 0;
        cin>>n;
        int nums[n];
        for (int i=0; i<n; i++)
                cin>>nums[i];

        int cnt = 0;
        sort(nums, nums+n);

        for (int i=0; i<n; i++) {
                for (int j=i+1; j<n; j++) {
                        if(nums[i]>= (double)(9.0/10)*nums[j])
                                cnt++;
                        else
                                break; //已经按照体重进行了排序，所以如果j不满足条件，那么后边的都不满足
                }
        }
        cout<<cnt<<endl;

        return 0;
}
```

## 3. 特殊的测试

题目描述：  

小C在做一种特殊的服务器负载测试，对于一个请求队列中的请求，每一个请求都有一个负荷值，为了保证服务器稳定，请求队列中的请求负荷必须按照先递增后递减的规律（仅递增，仅递减也可以），比如[1,2,8,4,3]和[1,3,5]都是满足要求的。还有一些不满足的，比如[1,2,2,1]和[2，1，2]。现在给你一个请求队列，你可以对请求的负荷值进行增加，要求调整完的序列满足要求。

输入：  

第一行是N（1<=N<=5000）,代表请求队列中的请求数量。  

第二行有N个整数Ai, Ai是第i个请求的负荷值。  

输出：  

输出这个最小增加总和。  

样例输入：

```c++
5
1 4 3 2 5
```

样例输出：  

```c++
6
```

样例说明：  

1 5 3+2 2+4 5 一共增加了2+4=6。    

code

```c++
│       ├── 37-GetNumberOfK.cpp
#include <iostream>
#include <vector>

using namespace std;
int main()
{
        int n = 0;
        cin>>n;
        int nums[n];
        for (int i=0; i<n; i++)
                cin>>nums[i];

        vector<int> back(nums, nums+n);

        if (n<2) {
                return 0;
        } else if (n==2) {
                if(nums[0] == nums[1])
                        return 1;
                else
                        return 0;
        } else {
                int i = 0;
                while (i<n-1 && nums[i]<nums[i+1])
                        i++;
                int j = n-1;
                while (j>0 && nums[j]<nums[j-1])
                        j--;
                while (i<j) {
                        if (nums[i] < nums[j]) {
                                if (nums[i] > nums[i+1])
                                        nums[i+1] = nums[i]+1;
                                i++;
                        } else {
                                if (nums[j] > nums[j-1])
                                        nums[j-1] = nums[j]+1;
                                j--;
                        }
                }
        }
        int sum = 0;
        for (int i=0; i<n; i++) {
                sum+=(nums[i]-back[i]);
        }
        cout<<sum<<endl;

        return 0;
}
```

## 4.  最长上升子序列

leetcode的第300道题目

题目描述：  

给定一个无序的整数数组，找到其中最长上升子序列的长度。  

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

code

```c++
#include <iostream>
#include <vector>

using namespace std;
int main()
{
        int n = 0;
        cin>>n;
        int nums[n];
        for (int i=0; i<n; i++)
                cin>>nums[i];
        int maxx = 0;

        int dp[n];
        for (int i=0; i<n; i++) {
                dp[i] = 1;
                for (int j=0; j<i; j++) {
                        if (nums[j] < nums[i])
                                dp[i] = max(dp[i], dp[j]+1);
                }
                if (dp[i] > maxx)
                        maxx = dp[i];
        }
        cout<<maxx<<endl;

        return 0;
}
```

